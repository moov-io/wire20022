package DrawdownRequest

import (
	"encoding/xml"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	pain013 "github.com/moov-io/fedwire20022/gen/DrawdownRequest_pain_013_001_07"
	"github.com/moov-io/fedwire20022/pkg/fedwire"
	model "github.com/moov-io/wire20022/pkg/models"
)

const XMLINS string = "urn:iso:std:iso:20022:tech:xsd:pain.013.001.07"

type MessageModel struct {
	//A unique identifier (IMADFedwireFunds1) assigned to the message.
	MessageId string
	//The creation date and time (ISODateTime) of the message.
	CreateDatetime time.Time
	//The total number of transactions (Max15NumericTextFixed) included in the message.
	NumberofTransaction string
	//In the Fedwire Funds Service, this is a person or entity that requests a drawdown.
	InitiatingParty model.PartyIdentify

	//Reference assigned by a sending party to unambiguously identify the payment information block within the message.
	PaymentInfoId string
	//Specifies the means of payment that will be used to move the amount of money.
	PaymentMethod PaymentMethod
	//Date at which the initiating party requests the clearing agent to process the payment. If payment by cheque, the date when the cheque must be generated by the bank.
	RequestedExecutDate model.Date
	//Party that owes an amount of money to the (ultimate) creditor.
	Debtor model.PartyIdentify
	//This is the account that will be debited by the debtor agent if the drawdown request is honored.
	DebtorAccountOtherId string
	//Financial institution servicing an account for the debtor.
	DebtorAgent model.Agent
	//Payment processes required to transfer cash from the debtor to the creditor.
	CreditTransTransaction CreditTransferTransaction
}
type Message struct {
	data MessageModel
	doc  pain013.Document
}

func NewMessage() Message {
	return Message{
		data: MessageModel{},
	}
}
func (msg *Message) CreateDocument() {
	msg.doc = pain013.Document{
		XMLName: xml.Name{
			Space: XMLINS,
			Local: "Document",
		},
	}
	var CdtrPmtActvtnReq pain013.CreditorPaymentActivationRequestV07
	var GrpHdr pain013.GroupHeader781
	if msg.data.MessageId != "" {
		GrpHdr.MsgId = pain013.IMADFedwireFunds1(msg.data.MessageId)
	}
	if !isEmpty(msg.data.CreateDatetime) {
		GrpHdr.CreDtTm = fedwire.ISODateTime(msg.data.CreateDatetime)
	}
	if msg.data.NumberofTransaction != "" {
		GrpHdr.NbOfTxs = pain013.Max15NumericTextFixed(msg.data.NumberofTransaction)
	}
	if !isEmpty(msg.data.InitiatingParty) {
		GrpHdr.InitgPty = PartyIdentification1351From(msg.data.InitiatingParty)
	}
	if !isEmpty(GrpHdr) {
		CdtrPmtActvtnReq.GrpHdr = GrpHdr
	}
	var PmtInf pain013.PaymentInstruction311
	if msg.data.PaymentInfoId != "" {
		PmtInf.PmtInfId = pain013.Max35Text(msg.data.PaymentInfoId)
	}
	if msg.data.PaymentMethod != "" {
		PmtInf.PmtMtd = pain013.PaymentMethod7Code1(msg.data.PaymentMethod)
	}
	if !isEmpty(msg.data.RequestedExecutDate) {
		Dt := msg.data.RequestedExecutDate.Date()
		PmtInf.ReqdExctnDt = pain013.DateAndDateTime2Choice1{
			Dt: &Dt,
		}
	}
	if !isEmpty(msg.data.Debtor) {
		PmtInf.Dbtr = PartyIdentification1352From(msg.data.Debtor)
	}
	if msg.data.DebtorAccountOtherId != "" {
		Othr := pain013.GenericAccountIdentification1{
			Id: pain013.Max34Text(msg.data.DebtorAccountOtherId),
		}
		DbtrAcct := pain013.CashAccount38{
			Id: pain013.AccountIdentification4Choice{
				Othr: &Othr,
			},
		}
		PmtInf.DbtrAcct = &DbtrAcct
	}
	if !isEmpty(msg.data.DebtorAgent) {
		Cd := pain013.ExternalClearingSystemIdentification1CodeFixed(msg.data.DebtorAgent.PaymentSysCode)
		DbtrAgt := pain013.BranchAndFinancialInstitutionIdentification61{
			FinInstnId: pain013.FinancialInstitutionIdentification181{
				ClrSysMmbId: pain013.ClearingSystemMemberIdentification21{
					ClrSysId: pain013.ClearingSystemIdentification2Choice1{
						Cd: &Cd,
					},
					MmbId: pain013.RoutingNumberFRS1(msg.data.DebtorAgent.PaymentSysMemberId),
				},
			},
		}
		PmtInf.DbtrAgt = DbtrAgt
	}
	if !isEmpty(msg.data.CreditTransTransaction) {
		PmtInf.CdtTrfTx = CreditTransferTransaction351From(msg.data.CreditTransTransaction)
	}
	if !isEmpty(PmtInf) {
		CdtrPmtActvtnReq.PmtInf = PmtInf
	}
	if !isEmpty(CdtrPmtActvtnReq) {
		msg.doc.CdtrPmtActvtnReq = CdtrPmtActvtnReq
	}
}
func WriteXMLTo(filePath string, xml []byte) error {
	os.Mkdir("generated", 0755)
	xmlFileName := filepath.Join("generated", filePath)

	xmlString := string(xml)
	xmlString = removeExtraXMLNS(xmlString)
	re := regexp.MustCompile(`>(\d+\.\d+(?:e[+-]?\d+)?|\d+e[+-]?\d+)<`)

	// Replace matched numbers with properly formatted ones
	xmlString = re.ReplaceAllStringFunc(xmlString, func(match string) string {
		// Extract the number inside the tags
		numberStr := strings.Trim(match, "<>")

		// Convert to float
		number, err := strconv.ParseFloat(numberStr, 64)
		if err != nil {
			return match // Return the original string if conversion fails
		}

		// Format it as a standard decimal number with 2 decimal places
		return fmt.Sprintf(">%.2f<", number)
	})

	re = regexp.MustCompile(`<(FrSeq|ToSeq)>(\d+)</(FrSeq|ToSeq)>`)

	// Replace numeric values with zero-padded format (6 digits)
	xmlString = re.ReplaceAllStringFunc(xmlString, func(match string) string {
		parts := re.FindStringSubmatch(match)
		if len(parts) == 4 {
			num := parts[2] // Extract number as string
			return fmt.Sprintf("<%s>%06s</%s>", parts[1], num, parts[3])
		}
		return match
	})

	return os.WriteFile(xmlFileName, []byte(xmlString), 0644)
}
func removeExtraXMLNS(xmlStr string) string {
	// Find the first occurrence of <Document ...> (keep this)
	docStart := strings.Index(xmlStr, "<Document")
	if docStart == -1 {
		return xmlStr // Return original if <Document> not found
	}

	// Find the end of the <Document> opening tag
	docEnd := strings.Index(xmlStr[docStart:], ">")
	if docEnd == -1 {
		return xmlStr
	}
	docEnd += docStart // Adjust index

	// Remove all occurrences of xmlns="..." except in <Document>
	cleanXML := xmlStr[:docEnd+1] + // Keep <Document> with its xmlns
		strings.ReplaceAll(xmlStr[docEnd+1:], ` xmlns="`+XMLINS+`"`, "")

	return cleanXML
}
