package DrawdownRequest_013_001_07

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"cloud.google.com/go/civil"
	DrawdownRequest "github.com/moov-io/fedwire20022/gen/DrawdownRequest_pain_013_001_07"
	"github.com/moov-io/fedwire20022/pkg/fedwire"
	model "github.com/moov-io/wire20022/pkg/models"
)

type Pain013 struct {
	//A unique identifier (IMADFedwireFunds1) assigned to the message.
	MessageId string
	//The creation date and time (ISODateTime) of the message.
	CreateDatetime time.Time
	//The total number of transactions (Max15NumericTextFixed) included in the message.
	NumberofTransaction string
	//In the Fedwire Funds Service, this is a person or entity that requests a drawdown.
	InitiatingParty model.PartyIdentify

	//Reference assigned by a sending party to unambiguously identify the payment information block within the message.
	PaymentInfoId string
	//Specifies the means of payment that will be used to move the amount of money.
	PaymentMethod PaymentMethod
	//Date at which the initiating party requests the clearing agent to process the payment. If payment by cheque, the date when the cheque must be generated by the bank.
	RequestedExecutDate civil.Date
	//Party that owes an amount of money to the (ultimate) creditor.
	Debtor model.PartyIdentify
	//This is the account that will be debited by the debtor agent if the drawdown request is honored.
	DebtorAccountOtherId string
	//Financial institution servicing an account for the debtor.
	DebtorAgent model.Agent
	//Payment processes required to transfer cash from the debtor to the creditor.
	CreditTransTransaction CreditTransferTransaction
}
type Pain013Message struct {
	model Pain013
	doc   DrawdownRequest.Document
}

func NewPain013Message() Pain013Message {
	return Pain013Message{
		model: Pain013{},
	}
}
func (msg *Pain013Message) CreateDocument() {
	msg.doc = DrawdownRequest.Document{
		XMLName: xml.Name{
			Space: "urn:iso:std:iso:20022:tech:xsd:pain.013.001.07",
			Local: "Document",
		},
	}
	var CdtrPmtActvtnReq DrawdownRequest.CreditorPaymentActivationRequestV07
	var GrpHdr DrawdownRequest.GroupHeader781
	if msg.model.MessageId != "" {
		GrpHdr.MsgId = DrawdownRequest.IMADFedwireFunds1(msg.model.MessageId)
	}
	if !isEmpty(msg.model.CreateDatetime) {
		GrpHdr.CreDtTm = fedwire.ISODateTime(msg.model.CreateDatetime)
	}
	if msg.model.NumberofTransaction != "" {
		GrpHdr.NbOfTxs = DrawdownRequest.Max15NumericTextFixed(msg.model.NumberofTransaction)
	}
	if !isEmpty(msg.model.InitiatingParty) {
		GrpHdr.InitgPty = PartyIdentification1351From(msg.model.InitiatingParty)
	}
	if !isEmpty(GrpHdr) {
		CdtrPmtActvtnReq.GrpHdr = GrpHdr
	}
	var PmtInf DrawdownRequest.PaymentInstruction311
	if msg.model.PaymentInfoId != "" {
		PmtInf.PmtInfId = DrawdownRequest.Max35Text(msg.model.PaymentInfoId)
	}
	if msg.model.PaymentMethod != "" {
		PmtInf.PmtMtd = DrawdownRequest.PaymentMethod7Code1(msg.model.PaymentMethod)
	}
	if !isEmpty(msg.model.RequestedExecutDate) {
		Dt := fedwire.ISODate(msg.model.RequestedExecutDate)
		PmtInf.ReqdExctnDt = DrawdownRequest.DateAndDateTime2Choice1{
			Dt: &Dt,
		}
	}
	if !isEmpty(msg.model.Debtor) {
		PmtInf.Dbtr = PartyIdentification1352From(msg.model.Debtor)
	}
	if msg.model.DebtorAccountOtherId != "" {
		Othr := DrawdownRequest.GenericAccountIdentification1{
			Id: DrawdownRequest.Max34Text(msg.model.DebtorAccountOtherId),
		}
		DbtrAcct := DrawdownRequest.CashAccount38{
			Id: DrawdownRequest.AccountIdentification4Choice{
				Othr: &Othr,
			},
		}
		PmtInf.DbtrAcct = &DbtrAcct
	}
	if !isEmpty(msg.model.DebtorAgent) {
		Cd := DrawdownRequest.ExternalClearingSystemIdentification1CodeFixed(msg.model.DebtorAgent.PaymentSysCode)
		DbtrAgt := DrawdownRequest.BranchAndFinancialInstitutionIdentification61{
			FinInstnId: DrawdownRequest.FinancialInstitutionIdentification181{
				ClrSysMmbId: DrawdownRequest.ClearingSystemMemberIdentification21{
					ClrSysId: DrawdownRequest.ClearingSystemIdentification2Choice1{
						Cd: &Cd,
					},
					MmbId: DrawdownRequest.RoutingNumberFRS1(msg.model.DebtorAgent.PaymentSysMemberId),
				},
			},
		}
		PmtInf.DbtrAgt = DbtrAgt
	}
	if !isEmpty(msg.model.CreditTransTransaction) {
		PmtInf.CdtTrfTx = CreditTransferTransaction351From(msg.model.CreditTransTransaction)
	}
	if !isEmpty(PmtInf) {
		CdtrPmtActvtnReq.PmtInf = PmtInf
	}
	if !isEmpty(CdtrPmtActvtnReq) {
		msg.doc.CdtrPmtActvtnReq = CdtrPmtActvtnReq
	}
}
func (msg *Pain013Message) GetXML() ([]byte, error) {
	xmlData, err := xml.MarshalIndent(msg.doc, "", "\t")
	if err != nil {
		return nil, err
	}

	// Convert byte slice to string for manipulation
	xmlString := string(xmlData)

	// Keep the xmlns only in the <Document> tag, remove from others
	xmlString = removeExtraXMLNS(xmlString)

	// Regular expression to match scientific notation (e.g., 9.93229443e+06)
	re := regexp.MustCompile(`>(\d+\.\d+(?:e[+-]?\d+)?|\d+e[+-]?\d+)<`)

	// Replace matched numbers with properly formatted ones
	xmlString = re.ReplaceAllStringFunc(xmlString, func(match string) string {
		// Extract the number inside the tags
		numberStr := strings.Trim(match, "<>")

		// Convert to float
		number, err := strconv.ParseFloat(numberStr, 64)
		if err != nil {
			return match // Return the original string if conversion fails
		}

		// Format it as a standard decimal number with 2 decimal places
		return fmt.Sprintf(">%.2f<", number)
	})

	// Convert back to []byte
	return []byte(xmlString), nil
	// return xml.MarshalIndent(msg.doc, "", "\t")
}
func (msg *Pain013Message) GetJson() ([]byte, error) {
	return json.MarshalIndent(msg.doc.CdtrPmtActvtnReq, "", " ")
}

func removeExtraXMLNS(xmlStr string) string {
	// Find the first occurrence of <Document ...> (keep this)
	docStart := strings.Index(xmlStr, "<Document")
	if docStart == -1 {
		return xmlStr // Return original if <Document> not found
	}

	// Find the end of the <Document> opening tag
	docEnd := strings.Index(xmlStr[docStart:], ">")
	if docEnd == -1 {
		return xmlStr
	}
	docEnd += docStart // Adjust index

	// Remove all occurrences of xmlns="..." except in <Document>
	cleanXML := xmlStr[:docEnd+1] + // Keep <Document> with its xmlns
		strings.ReplaceAll(xmlStr[docEnd+1:], ` xmlns="urn:iso:std:iso:20022:tech:xsd:pain.013.001.07"`, "")

	return cleanXML
}
